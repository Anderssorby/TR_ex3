---
title: "Analysis of an ARMA process"
subtitle: "TMA4285 Time series models - Exercise 3"
author: Anders Christiansen Sørby, Edvard Hove
#bibliography: mybiblio.bib
header-includes:
  - \usepackage{dsfont}
  - \usepackage{bm}
  - \DeclareMathOperator*{\E}{\mathbb{E}}
output: pdf_document
keep_tex: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Abstract
Blabla

# Introduction

## The ARMA process
A stationary process \(\{X_t\}\) is an \(ARMA(p,q)\) process if the following relation exists

\begin{equation}
\phi(B)X_t = \theta(B)Z_t
\label{eq:arma}
\end{equation}

where \(Z_t \sim \bf{WN}(0, \sigma^2)\), and \(\phi(\cdot)\) and \(\theta(\cdot)\) are polynomials (with no common factors) given by

\begin{equation}
\phi(z) = 1 - \phi_1 z - \phi_2 z^2 - \dots - \phi_p z^p
\end{equation}

and
\begin{equation}
\theta(z) = 1 + \theta_1 z + \theta_2 z^2 +  \dots + \theta_q z^q,
\end{equation}

and B is the backward shift operator. That is \(B^j X_t = X_{t-j}, j \in \mathds{Z}\).

In particular an \(ARMA(2,1)\) process is given by
$$
X_t -\phi_1 X_{t-1} - \phi_2 X_{t-2} = Z_t + \theta_1 Z_{t-1}
$$

# Theory
An expression for \(\{X_t | t \in \mathds{Z}\}\) satisfying equation \eqref{eq:arma} on the form

\begin{equation}
X_t = \sum_{j = -\infty}^\infty \psi_j Z_{t-j}
\end{equation}

is said to be a stationary solution. A stationary solution exists, and is also unique, if no roots of the autoregressive polynomial \(\phi(z)\) lie on the unit circle. If \(X_t\) can be expressed in terms of \(Z_s,s \leq t\) we say that the process is causal. Such an expression is guaranteed to exist if no roots of \(\phi(z)\) lie on the unit disk.
Include how the \(\phi \theta\) is estimated

\begin{equation}
  \label{eq:psi}
  X_t = \psi (B) Z_t = \sum _{i=0}^\infty \psi_{i}Z_{t-i}
\end{equation}

By substituting the expression for \(X_t\) from \eqref{eq:psi} into equation \eqref{eq:arma} we get 

\begin{equation}
  \phi(B)\psi(B)Z_t = \theta(B)Z_t, 
\end{equation}

which can only be satisfied if \(\phi(B)\psi(B) = \theta(B)\). That is

\begin{equation}
  (1-\phi_1 B - \phi_2 B^2)\sum _{i=0}^\infty \psi_{i}B^i = 1 + \theta_1 B.
\end{equation}

Two polynomials are only equal if all their coefficients are equal, which gives us the following expressions for \(\psi_i\)

\begin{equation}
\label{eq:phicases}
  \psi_i = 
  \begin{cases}
    1, & i=0\\
    \theta_1 + \phi_1\psi_0, & i=1\\
    \phi_1\psi_{i-1} + \phi_2\psi_{i-2}, & i>1
  \end{cases}
\end{equation}

The process is said to be invertible if \(\theta(z)\neq0\) for \(|z|\leq1\). In that case we get the following expression for \(Z_t\)

\begin{equation}
  \label{eq:pi}
  Z_t = \pi (B) X_t = \sum _{i=0}^\infty \pi_{i}X_{t-i}
\end{equation}

In the same way as for \(\phi_i\), we can find the expressions for \(\pi_i\)

\begin{equation}
\label{eq:picases}
  \pi_i = 
  \begin{cases}
    1, & i=0\\
    -\theta_1\pi_0 - \phi_1, & i=1\\
    -\theta_1\pi_1 - \phi_2, & i=2\\
    -\theta_1\pi_{i-1}, & i>2
  \end{cases}
\end{equation}

## Model parameter estimation
The \(ARMA(2,1)\) process (with zero mean) consists of 4 parameters that need to be estimated. That is \(\phi_1, \phi_2, \theta_1 \text{ and } \sigma^2\). This can be done in a number of ways. A simple and consistent way is the method of moments. The idea is to take the expected value of the expression of \(X_t\) multiplied with \(X_{t-h}\).

\begin{equation}
{\E}[X_t X_{t-h}] = {\E}[(Z_t + \theta_1 Z_{t-1} + \phi_1 X_{t-1} + \phi_2 X_{t-2})X_{t-h}]
\end{equation}

This then gives a set of equations containing the autocovariance function  \(\gamma(h)\) and the parameters. By using the sample autocovariance function \(\hat \gamma(h)\) in place of the autocovariance function we can solve the equations, resulting in estimates of the parameters of interest.

The estimators found using this method may be biased and they often have high variance compared to other estimators. They are however useful as first approximations in numerical methods of estimation.

Another way is to use the maximum likelihood estimators. The Gaussian likelihood for an ARMA process is given by

\begin{equation}
L(\bm\phi, \bm\theta, \sigma^2) = \frac{1}{\sqrt{(2\pi\sigma^2)^n r_0\hdots   r_{n-1}}}\text{exp}\left(\frac{-1}{2\sigma^2}\sum_{j=1}^n\frac{(X_j-\hat X_j)^2}{r_{j-1}}\right)
\end{equation}


REPEATED ESTIMATION ON SIMULATED DATA COMES HERE:
IN ORDER TO USE arima.sim WE NEED AN EXPRESSION FOR THE INNOVATIONS

We need to confirm that a given process is indeed an $ARMA(2,1)$


```{r read, echo=FALSE}
x = read.table("DataEx3G8.txt")
x <- x[,1]
```
# Data analysis
The language R has many built-in functions for analysing timeseries. 

Our recieved realization of the process can be seen in the next plot.

```{r TSMplot, echo=FALSE}
plot(seq(1,500),x,type="l", xlab="t", ylab="X_t")
```

There is no obvious need for a transformation of the data to fit an ARMA model. Based on the plot it seems probable that both the mean and variance is constant with respect to time. (DETTE HADDE VÆRT FINT Å DEMONSTRERE)

```{r lagplot, echo=FALSE}
lag.plot(x, 9, diag.col = "red")
```

```{r arma}
arima=arima(x,order=c(2,0,1))

phi1 <- arima$coef[1]
phi2 <- arima$coef[2]
ar <- c(phi1,phi2)

theta1 <- arima$coef[3]
ma <- c(theta1)

sigma2 <- arima$sigma2
sigma <- sqrt(sigma2)
```
```{r acvf}
lag.max=100
acf=acf(x,lag.max=lag.max)
lines(seq(0,lag.max),ARMAacf(ar=ar,ma=ma,lag.max=lag.max),col=2,lty=3)
```
```{r transform}
p=10
c=2*pi/p
y=asin(c*x)
```

It is conceivable, based on the sample autocorrelation function, that there is some underlying seasonal lag. the functions `decompose` and `stl` in R claims that the series is not periodic.  More importantly the sample ACF forces us to reject the hypothesis that the data is generated by an \(MA(q)\) model (atleast for \(q\leq 50\)).

```{r pacf}
lag.max=100
acf=acf(x,type="partial",lag.max=lag.max)
lines(seq(0,lag.max),ARMAacf(ar=ar,ma=ma,lag.max=lag.max),pacf=TRUE,col=2,lty=3)
```

```{r armasim}
xsim <- arima.sim(n=500, list(ar=ar, ma=ma,order=c(2,0,1)),sd=sigma)
plot(xsim)
```

Using the function `arima` we get MLE parameter estimates for our the underlying distribution. 
```{r arimamodel}
print(arima)
```

We can then check the causality criterion by solving
\begin{equation}
\phi(z) = 1 - `r sprintf('%.3f', arima$coef[1])`z + `r sprintf('%.3f', abs(arima$coef[2]))`z^2 =0,
\end{equation}

```{r roots, include=FALSE}
z_1=(phi1-sqrt(phi1^2 +4*phi2))/(-2*phi2)
z_2=(phi1+sqrt(phi1^2 +4*phi2))/(-2*phi2)
```

which gives us the roots \(z_1 \approx `r sprintf('%.3f', z_1)`\) and \(z_2 \approx `r sprintf('%.3f', z_2)`\). Since both these roots are outside the unit disk there exists an expression for \(X_t\) on the form



Since the MA polynomial \(\theta(z)\) has the single root \(z \approx `r sprintf('%.3f', 1/theta1)`\), \(X_t\) is also invertable, which means \(Z_t\) can be given by


## Model prediction

Given the two preciding values and our estimated \(Z_t\sim\bf{WN}(0, \sigma^2)\)-values we can predict the next value of the time series and compare them to the actual value.

```{r prediction}
source('Zestimates.R')
est <- estimateZ(x)

plot(est)
#print(est)
Z <- est$Z
Znew <- rnorm(500,sd=est$sd)

m <- est$m
n <- est$n
l <- est$l
prod_arma <- function(Z, n){
  pred <- rep(0, l)
  residuals <- rep(0,l)
  
  for (i in seq(max(n+1,3), l)) {
    pred[i] <- phi1*pred[i-1] + phi2*pred[i-2] + Z[i] + theta1*Z[i-1]
    residuals[i] <- x[i] - pred[i]
  }
  res <- list(pred=pred, residuals=residuals)
  class(res) <- "prod_arma"
  return(res)
}

res1 <- prod_arma(Z, n=n)
res2 <- prod_arma(Znew, n=0)

```
```{r prediction-plot}
library(latex2exp)

plot.arma_prod <- function(prod) {
  pred <- prod$pred
  residuals <- prod$residuals
  plot(pred[n+1:l], main = "Model prediction", ylab = TeX("X_t,\\hat{X}_t"), xlab = "t", type = "l", col="blue")
  lines(x[n+1:l], type = "l", col="red")
  
  plot(residuals[n+1:l])
}
plot.arma_prod(res2)
```

``` {r forecasting}
fore <- predict(arima,20)
ts.plot(c(x,fore$pred),col=1:2,xlim=c(420,520))
U <- fore$pred+fore$se
L <- fore$pred-fore$se
xx = c(time(U), rev(time(U))); yy = c(L, rev(U))
polygon(xx, yy, border = 8, col = gray(.6, alpha = .2))
lines(fore$pred, type="p", col=2)
```

# Discussion

Bla bla


# Conclusion

This was ..

# Appendix

Everything not in the main section
This also includes R-code as a whole

# References

